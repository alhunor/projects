#include "actors.h"
#include "events.h"
//#include "tokenizer.h"
#include "utils.h"
#include <string>
#include <iostream>

#include <io.h>
#include <fcntl.h>
#include <vector>

using namespace std;
extern guidClass guids;


actor::actor(wowEvent* eve)
{
//	name = guids.lookUpFriendly(eve->sourceGUID).name;
	guid = eve->sourceGUID;
}

petT::petT(wowEvent* eve) : actor(eve)
{
	atype = Pet;
	if (eve->etype == SPELL_SUMMON)
	{
		petName = guids.lookUp(eve->destGUID).name;
	}
	else
	{
		petName = guids.lookUp(eve->sourceGUID).name;
	}
//	name = raid[eve->destGUID].name; ??
}

player::player(wowEvent* eve) : actor(eve) 
{
	atype = Player; 
#ifdef _DEBUG
	playerName = eve->sourceName;
#endif
}


player::~player()
{
	petListT::const_iterator it;
	for (it = pets.begin(); it != pets.end(); ++it)
	{
		delete *it;
	}

}


actors::~actors()
{
	actorMapT::const_iterator it;
	for (it = actorMap.begin(); it != actorMap.end(); ++it)
	{
		delete it->second;
	}
}

actor::~actor()
{
	wowEventListT::const_iterator it2;
	for (it2 = actions.begin(); it2 != actions.end(); ++it2)
	{
		delete *it2;
	}
}


petT* actors::searchPetOwner(std::string petName, GUID  ownerName)
{
	actorMapT::const_iterator search;
	petListT::const_iterator searchPet;
	petT* pet;

	search = actorMap.find(ownerName);
	if (search == actorMap.end())
		return NULL;

	player* owner = static_cast<player*>(search->second);
	for (searchPet = owner->pets.begin(); searchPet != owner->pets.end(); ++searchPet)
	{
		pet = *searchPet;
		if (pet->petName == petName) // found an event generated by the pet
		{
			return pet;
		}
	}
	return NULL;
} // petT* actors::searchPetOwner(std::string petName, std::string ownerName)


void actors::add(wowEvent* eve)
{
	actor* actor;
	petT* pet;
	actorMapT::const_iterator search;
	petListT::const_iterator searchPet;

	if (eve->time_ms < minTime)
	{
		minTime = eve->time_ms;
	} else 	if (eve->time_ms > minTime)
	{
		maxTime = eve->time_ms;
	}

	
	// Exit is actor is not friendly;
	if (!checkFlags(eve->sourceFlags, COMBATLOG_OBJECT_REACTION_FRIENDLY))
		return;

	// Register summoned Pets with thir owners
	if (eve->etype == SPELL_SUMMON)
	{
		//std::string petName = eve->destName;
		petOwners[eve->destName] = eve->sourceGUID;
		player* owner;

		search = actorMap.find(eve->sourceGUID);
		if (search == actorMap.end())
		{
			throw "TODO :: Create the player and store it in ownerr and actorMap";
			owner = NULL; 
		} else
		{
			owner = static_cast<player*>(search->second);
		}
		bool found = false;
		for (searchPet = owner->pets.begin(); searchPet != owner->pets.end(); ++searchPet)
		{
			pet = *searchPet;
			if (pet->petName == eve->destName) // found an event summoning the pet
			{
				found = true;
			}
		}
		if (!found)
		{
			// create pet and store it in player
			pet = new petT(eve);
			owner->pets.push_back(pet);
		}
		// All is done, we can exit actors::add(wowEvent* eve)
		return;
	} // if (eve->etype == SPELL_SUMMON)

	  // Find pets if it performs an action
	if (eve->etype == SPELL_CAST_SUCCESS && checkFlags(eve->sourceFlags, COMBATLOG_OBJECT_TYPE_PET))
	{
		//GUID petGUID = eve->sourceGUID;
		string petName = eve->sourceName;
		GUID ownerGUID = ((spellCastSuccess*)eve)->resourceActor;

		player* owner;

		search = actorMap.find(ownerGUID);
		if (search == actorMap.end())
		{
			throw "TODO :: Create the player and store it in ownerr and actorMap";
			owner = NULL;
		}
		else
		{
			owner = static_cast<player*>(search->second);
		}
		bool found = false;
		for (searchPet = owner->pets.begin(); searchPet != owner->pets.end(); ++searchPet)
		{
			pet = *searchPet;
			if (pet->petName == petName) // found an event generated by the pet
			{
				found = true;
			}
		}
		if (!found)
		{
			// create pet and store it in player
			pet = new petT(eve);
			owner->pets.push_back(pet);
		}
		// All is done, we can exit actors::add(wowEvent* eve)
		return;
	}

	//guidImpl gi = guids.lookUpFriendly(eve->sourceGUID);

	switch(eve->atype)
	{
	case Player:
		if (!checkFlags(eve->sourceFlags, COMBATLOG_OBJECT_TYPE_PLAYER))
			return;
		search = actorMap.find(eve->sourceGUID);
		if (search == actorMap.end())
		{
			{
				/*if (isPrefix("Kettle-Arathor", eve->sourceName.c_str()))
				{
					actor = new arcaneMage(eve);
				}
				else*/
				{
					actor = new player(eve);
				}
				actorMap[eve->sourceGUID] = actor;
			}
		} else
		{
			actor = search->second;
		}
		// process the event
		actor->actions.push_back(eve);
		actor->processEvent(eve);
		break;
	case Pet:
	case Creature:
		if (!checkFlags(eve->sourceFlags, COMBATLOG_OBJECT_CONTROL_PLAYER))
			return;
		pet = searchPetOwner(eve->sourceName, petOwners[eve->sourceName]);
		if (pet)
		{
			pet->actions.push_back(eve);
			//pet->processEvent(eve);
		} else
		{
			//std::cout << "Unknown pet" << std::endl; 
		}
		break;
	} // switch(actorType(eve))
} // actorType actors::add(wowEvent* eve)



bool actor::processEvent(wowEvent* eve)
{
	return true;
} // bool actor::processEvent(wowEvent* eve)


bool player::processEvent(wowEvent* eve)
{
	return actor::processEvent(eve);
}


bool arcaneMage::processEvent(wowEvent* eve)
{
	bool b = mage::processEvent(eve);

	switch (eve->etype)
	{
	case SPELL_DAMAGE:
		break;
	default:
		return false;
	}
	return b;
} // bool arcaneMage::processEvent(wowEvent* eve)


struct damageStat
{
	damageStat() : min(9999999), max(0), sum(0), sum2(0), n(0) {}
	double min, max;
	double sum, sum2;
	int n;
	void add(double damageInc);
	double stdev();
};

void damageStat::add(double damageInc)
{
	n++;
	sum += damageInc;
	sum2 += damageInc*damageInc;
	max = max>damageInc?max: damageInc;
	min = min<damageInc ? min : damageInc;
}

double damageStat::stdev()
{
	if (n <= 1) return 0;
	double res = (sum2 - sum*sum/n) / (n - 1);
	return sqrt(res);
}


typedef map<int, damageStat> DS;
typedef map<string, damageStat> DS2;

extern map<int, string> spells;


void actors::stat()
{
	actorMapT::const_iterator it;
	petListT::const_iterator it2;
	wowEventListT::const_iterator it3;
	wowEvent* eve;
	actor* a;
	player *p;
	petT *pet;

	_setmode(_fileno(stdout), _O_U16TEXT);
	wchar_t* w;
	int count = 0;
	wcout.precision(17);
//Damage per spell
	wcout << "damage per spell\n";
	for (it = actorMap.begin(); it != actorMap.end(); ++it)
	{
		a = it->second;
		if (a->atype == Player)
		{
			p = (player*)a;
		}
		else
		{
			throw "Actor list has been contaminated by non-player entitities";
		}

		DS dmg;
		spells[0] = "SwingDamage";
		int damageInc;
		int damageDone = 0;
		int friendlyDamage = 0;
		for (it3 = a->actions.begin(); it3 != a->actions.end(); ++it3)
		{
			eve = *it3;
			spellDamage* sd;
			damageInc = eve->damage_amount();
			if (damageInc < 1) continue;
			if (! checkFlags(eve->destFlags, COMBATLOG_OBJECT_REACTION_HOSTILE))
			{
				// ignore mage damage on Prismatic Crystal
				if (eve->destName == "Prismatic Crystal") continue;
				friendlyDamage += damageInc;
				//continue;
			}
			damageDone += damageInc;
			string s;
			switch (eve->etype)
			{
			case SPELL_DAMAGE:
				sd = (spellDamage*) eve;
				dmg[sd->spellID].add(damageInc);
				//s = spells[sd->spellID];
				//wcout << s.c_str() << "," << damageInc << endl;
				break;
			case SWING_DAMAGE:
				dmg[0].add(damageInc);
				break;
			default:
				break;
			} // switch (eve->etype)
		} // for (it3 = a->actions.begin(); it3 != a->actions.end(); ++it3)

		w = convert(p->playerName.c_str());
		std::wcout << w << " Hostile  " << damageDone ;
		std::wcout << " Friendly  " << friendlyDamage << std::endl;
		delete[] w;
		map<int, damageStat>::const_iterator it4;
		for (it4 = dmg.begin(); it4 != dmg.end(); ++it4)
		{			
			int spellID = it4->first;
			string s = spells[spellID];
			wcout << " ->" << s.c_str() << " , " << dmg[spellID].n<<" , " <<  dmg[spellID].min << " , " << dmg[spellID].max << " , " << trunc(dmg[spellID].sum/dmg[spellID].n) <<
				" , " << trunc(dmg[spellID].stdev())  <<endl;
		}

		for (it2 = p->pets.begin(); it2 != p->pets.end(); ++it2)
		{
			pet = *it2;
			int petDamageDone = 0;
			for (it3 = pet->actions.begin(); it3 != pet->actions.end(); ++it3)
			{
				wowEvent* eve = *it3;
				petDamageDone += eve->damage_amount();
			}
			w = convert(pet->petName.c_str());
			if (petDamageDone > 0)
			{
				std::wcout << "     " << w << "   " << petDamageDone << std::endl;
			}
			delete[] w;
		} // Pet damage
	} // for (it = actorMap.begin(); it != actorMap.end(); ++it) for damage per spell

// now we compute damage per target

	wcout << "Damage per enemey\n";

//Damage per spell
	for (it = actorMap.begin(); it != actorMap.end(); ++it)
	{
		a = it->second;
		if (a->atype == Player)
		{
			p = (player*)a;
		}
		else
		{
			throw "Actor list has been contaminated by non-player entitities";
		}
		DS2 dmg;
		int damageInc;
		int damageDone = 0;
		for (it3 = a->actions.begin(); it3 != a->actions.end(); ++it3)
		{
			wowEvent* eve = *it3;
			damageInc = eve->damage_amount();
			if (damageInc>0)
			{
				damageDone += damageInc;
				dmg[eve->destName].add(damageInc);
			}
		} // for (it3 = a->actions.begin(); it3 != a->actions.end(); ++it3)

		w = convert(p->playerName.c_str());
		std::wcout << w << "   " << damageDone << std::endl;
		delete[] w;
		map<string, damageStat>::const_iterator it4;
		for (it4 = dmg.begin(); it4 != dmg.end(); ++it4)
		{
			string s = it4->first;
			wcout << " ->" << s.c_str() << " , " << it4->second.n << " , " << it4->second.sum << endl;
		}
		wcout << "Pets" << std::endl;
		for (it2 = p->pets.begin(); it2 != p->pets.end(); ++it2)
		{
			pet = *it2;
			for (it3 = pet->actions.begin(); it3 != pet->actions.end(); ++it3)
			{
				eve = *it3;
				damageInc = eve->damage_amount();
				if (damageInc>0)
				{
					dmg[eve->destName].add(damageInc);
				}
			}
		} // Pet damage
		for (it4 = dmg.begin(); it4 != dmg.end(); ++it4)
		{
			string s = it4->first;
			wcout << " ->" << s.c_str() << " , " << it4->second.n << " , " << it4->second.sum << endl;
		}
	} // for (it = actorMap.begin(); it != actorMap.end(); ++it) for damage per enemmy

} // void actors::stat()

  // Return dmg done in each sampling interval between [start, end). There are "nbPeriods" periods.
void actor::computeDamageTimeline(std::vector<int>& dmg, long start, long end, int nbPeriods)
{
	dmg.resize(nbPeriods);
	for (int i = 0; i < nbPeriods; ++i)
	{
		dmg[i] = 0;
	}
	if (end < start + 1) throw "Interval is ill defined";
	wowEventListT::const_iterator it3;
	int damageInc;
	long time;
	float freq = (float)nbPeriods/(end-start);
	int period;
	for (it3 = actions.begin(); it3 != actions.end(); ++it3)
	{
		wowEvent* eve = *it3;
		damageInc = eve->damage_amount();
		if (damageInc <= 0) continue;
		time = eve->time_ms;
		if (time < start || time >= end) continue;
		period = (int) ((time - start) * freq);
		dmg[period] += damageInc;
	}
} // void actor::computeDamageTimeline(std::vector<int>& dmg, long start, long end, int nbPeriods)


actor* actors::locate(std::string name)
{
	GUID h = guids.hash(name);
	actorMapT::const_iterator it;
	actor* a;

	for (it = actorMap.begin(); it != actorMap.end(); ++it)
	{
		a = it->second;
		if (a->guid == h)
		{
			return a;
		}
	}
	return NULL;
} // actor* actors::locate(std::string name)

